#!/bin/bash

# ==============================================================================
#  BTRFS FLAT LAYOUT MIGRATION TOOL
# ==============================================================================
#  Automatizza la conversione da layout Btrfs Nested a Flat.
#  Include snapshot di sicurezza, migrazione dati e gestione subvolumi.
# ==============================================================================

# --- CONFIGURAZIONE VISIVA ---
BOLD='\033[1m'
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Icone
ICON_OK="[âœ”]"
ICON_KO="[âœ˜]"
ICON_INFO="[i]"
ICON_WARN="[!]"
ICON_GEAR="[âš™]"
ICON_DISK="[ðŸ’¾]"

# Variabili Globali
MOUNT_POINT="/mnt"
LOG_FILE="btrfs_migration.log"

# --- FUNZIONI DI UTILITÃ€ ---

print_banner() {
    clear
    echo -e "${CYAN}${BOLD}"
    echo "   ___  _____  ___  ___  ___   ___  ___   ___  "
    echo "  | _ )|_   _|| _ \| __|/ __| / __|| _ \ | _ \ "
    echo "  | _ \  | |  |   /| _| \__ \| (__ |   / |  _/ "
    echo "  |___/  |_|  |_|_\|_|  |___/ \___||_|_\ |_|   "
    echo "                                               "
    echo "      FLAT LAYOUT MIGRATOR | LIMINE READY      "
    echo -e "${NC}"
    echo -e "${BLUE}====================================================${NC}"
}

log_step() {
    echo -e "\n${BLUE}${BOLD}:: $1${NC}"
    echo "Step: $1" >> "$LOG_FILE"
}

log_success() {
    echo -e "${GREEN}${ICON_OK} $1${NC}"
}

log_error() {
    echo -e "${RED}${ICON_KO} ERRORE: $1${NC}"
    exit 1
}

log_warn() {
    echo -e "${YELLOW}${ICON_WARN} ATTENZIONE: $1${NC}"
}

check_root() {
    if [[ $EUID -ne 0 ]]; then
       log_error "Questo script deve essere eseguito come root (sudo)."
    fi
}

check_dependency() {
    local cmd=$1
    echo -ne "   ${ICON_GEAR} Verifica ${cmd}...\r"
    if ! command -v $cmd &> /dev/null; then
        echo -e "${RED}${ICON_KO} Comando mancante: ${cmd}${NC}"
        log_error "Installa ${cmd} prima di procedere."
    else
        echo -e "${GREEN}${ICON_OK} Dipendenza soddisfatta: ${cmd}   ${NC}"
    fi
}

confirm_action() {
    echo -e -n "${YELLOW}   Sei sicuro di voler procedere? (s/N): ${NC}"
    read -r response
    if [[ ! "$response" =~ ^([sS][iI]|[sS])$ ]]; then
        echo -e "${RED}   Operazione annullata dall'utente.${NC}"
        exit 0
    fi
}

# --- LOGICA PRINCIPALE ---

main() {
        print_banner
        check_root
        
        # 1. Acquisizione Target
        echo -e -n "${BOLD}Inserisci la partizione di ROOT (es. /dev/sda2): ${NC}"
        read -r TARGET_DEV
        
        if [[ ! -b "$TARGET_DEV" ]]; then
            echo -e "${RED}Device non valido.${NC}"
            exit 1
        fi
        
        # 2. Montaggio della nuova gerarchia
        log_header "Montaggio struttura subvolumi in $MOUNT_POINT"
        
        # Smonta tutto per pulizia
        umount -R "$MOUNT_POINT" 2>/dev/null
        
        # Mount Root (@)
        echo -e "   ${ICON_DISK} Montaggio @ su /"
        mount -t btrfs -o subvol=@,compress=zstd,noatime "$TARGET_DEV" "$MOUNT_POINT"
        
        # Creazione directory mountpoint se mancanti (dovrebbero esserci dalla fase 1)
        mkdir -p "$MOUNT_POINT/home"
        mkdir -p "$MOUNT_POINT/.snapshots"
        mkdir -p "$MOUNT_POINT/var/log"
        mkdir -p "$MOUNT_POINT/boot/efi" # Assumendo EFI, crea se manca
        
        # Mount Subvolumi "Figli"
        echo -e "   ${ICON_DISK} Montaggio @home su /home"
        mount -t btrfs -o subvol=@home,compress=zstd,noatime "$TARGET_DEV" "$MOUNT_POINT/home"
        
        echo -e "   ${ICON_DISK} Montaggio @snapshots su /.snapshots"
        mount -t btrfs -o subvol=@snapshots,compress=zstd,noatime "$TARGET_DEV" "$MOUNT_POINT/.snapshots"
        
        echo -e "   ${ICON_DISK} Montaggio @var_log su /var/log"
        mount -t btrfs -o subvol=@var_log,compress=zstd,noatime "$TARGET_DEV" "$MOUNT_POINT/var/log"
        
        # 3. Generazione Fstab
        log_header "Generazione automatica /etc/fstab"
        
        FSTAB_FILE="$MOUNT_POINT/etc/fstab"
        # Backup del vecchio fstab
        cp "$FSTAB_FILE" "$FSTAB_FILE.bak.$(date +%s)"
        
        echo -e "   ${ICON_GEAR} Scrittura nuovo fstab..."
        
        # Ottieni UUID
        UUID=$(blkid -s UUID -o value "$TARGET_DEV")
        
        # Scrittura Fstab (Sovrascrittura controllata delle righe Btrfs)
        # Mantiene le altre entry (come swap o partizione EFI) se presenti nel backup? 
        # Per sicurezza, qui rigeneriamo le entry BTRFS essenziali.
        # NOTA: Se hai una partizione EFI separata (/boot/efi), dovrai assicurarti che sia nell'fstab.
        
        cat <<EOF > "$FSTAB_FILE"
        # /etc/fstab: static file system information.
        # Generated by Automated Script
        
        # <file system>                           <mount point>  <type>  <options>                                 <dump>  <pass>
        UUID=$UUID                                /              btrfs   subvol=@,defaults,noatime,compress=zstd   0       0
        UUID=$UUID                                /home          btrfs   subvol=@home,defaults,noatime,compress=zstd 0     0
        UUID=$UUID                                /.snapshots    btrfs   subvol=@snapshots,defaults,noatime,compress=zstd 0 0
        UUID=$UUID                                /var/log       btrfs   subvol=@var_log,defaults,noatime,compress=zstd 0  0
        
        # Recupera eventuali partizioni NON-btrfs dal vecchio fstab (es. /boot/efi o swap)
        EOF
        
        # Tentativo semplice di recuperare la partizione EFI dal vecchio fstab
        grep -v "btrfs" "$FSTAB_FILE.bak"* | grep -E "vfat|swap" | cut -d: -f2- >> "$FSTAB_FILE"
        
        echo -e "${GREEN}${ICON_OK} Fstab aggiornato.${NC}"
        
        # 4. Preparazione Chroot (Bind Mounts)
        log_header "Preparazione Ambiente Chroot (Bind API FS)"
        
        for dir in dev proc sys run; do
            mount --bind /$dir "$MOUNT_POINT/$dir"
            mount --make-rslave "$MOUNT_POINT/$dir" 
        done
        
        # Se c'Ã¨ una partizione EFI, prova a montarla
        # Cerca nel nuovo fstab dove Ã¨ montata /boot o /boot/efi
        EFI_PART=$(grep "/boot" "$FSTAB_FILE" | awk '{print $1}' | head -n 1)
        EFI_MOUNT=$(grep "/boot" "$FSTAB_FILE" | awk '{print $2}' | head -n 1)
        
        if [[ -n "$EFI_PART" && -n "$EFI_MOUNT" ]]; then
            # Risolvi UUID=... se necessario, ma mount di solito Ã¨ intelligente
            echo -e "   ${ICON_DISK} Rilevata partizione boot/efi in fstab, tentativo mount..."
            mount "$MOUNT_POINT/$EFI_MOUNT"
        fi
        
        
        # 5. Istruzioni Finali
        log_header "Pronto per l'aggiornamento di GRUB"
        echo -e "Il sistema Ã¨ montato e pronto in ${BOLD}$MOUNT_POINT${NC}"
        echo -e "Ora entrerai automaticamente in chroot."
        echo -e "Esegui questo comando una volta dentro:"
        echo -e "   ${GREEN}grub-mkconfig -o /boot/grub/grub.cfg${NC}"
        echo -e "(Su Ubuntu/Debian puoi usare semplicemente: ${GREEN}update-grub${NC})"
        echo ""
        echo -e "${YELLOW}Premi INVIO per entrare in Chroot (scrivi 'exit' per uscire)...${NC}"
        read
        
        chroot "$MOUNT_POINT" /bin/bash
        
        # Cleanup all'uscita
        echo -e "\n${BLUE}Uscita dal Chroot. Smontaggio volumi...${NC}"
        umount -R "$MOUNT_POINT"
        echo -e "${GREEN}${ICON_OK} Procedura terminata. Puoi riavviare.${NC}"
}

# Avvio
main
